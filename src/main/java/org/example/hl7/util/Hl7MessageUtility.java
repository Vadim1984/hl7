package org.example.hl7.util;

import ca.uhn.hl7v2.HL7Exception;
import ca.uhn.hl7v2.hoh.util.StringUtils;
import ca.uhn.hl7v2.model.DataTypeException;
import ca.uhn.hl7v2.model.v24.segment.MSH;
import ca.uhn.hl7v2.model.v24.segment.NTE;
import ca.uhn.hl7v2.model.v24.segment.OBR;
import ca.uhn.hl7v2.model.v24.segment.OBX;
import ca.uhn.hl7v2.model.v24.segment.ORC;
import ca.uhn.hl7v2.model.v24.segment.PID;
import ca.uhn.hl7v2.model.v24.segment.SAC;

public class Hl7MessageUtility {

    /**
     * Populate Message Header segment.
     *
     * @param mshSegment                    MSH segment.
     * @param messageControlId              GUID generated by the software to uniquely identify the message.
     * @param sendingApplication            The field uniquely identifies the sending application.
     * @param sendingFacility               The field further describes the sending application.
     * @param receivingApplication          This field uniquely identifies the receiving application among all other applications within the network enterprise.
     * @param receivingFacility             This field identifies the receiving application among multiple identical instances of the application running on behalf of different organizations.
     * @param dateTimeOfMessage             Date/time when the sending software created the message. Format: YYYYMMDDhhmmss.
     * @param acceptAcknowledgmentType      Date/time when the sending software created the message. Format: YYYYMMDDhhmmss.
     * @param applicationAcknowledgmentType Date/time when the sending software created the message. Format: YYYYMMDDhhmmss.
     */
    public static void populateMshSegment(final MSH mshSegment,
                                          final String messageControlId,
                                          final String sendingApplication,
                                          final String sendingFacility,
                                          final String receivingApplication,
                                          final String receivingFacility,
                                          final String dateTimeOfMessage,
                                          final String acceptAcknowledgmentType,
                                          final String applicationAcknowledgmentType) {
        try {
            mshSegment.getMessageControlID().setValue(messageControlId);
            mshSegment.getSendingApplication().getNamespaceID().setValue(sendingApplication);
            mshSegment.getSendingFacility().getNamespaceID().setValue(sendingFacility);
            mshSegment.getReceivingApplication().getNamespaceID().setValue(receivingApplication);
            mshSegment.getReceivingFacility().getNamespaceID().setValue(receivingFacility);
            mshSegment.getDateTimeOfMessage().getComponent(0).parse(dateTimeOfMessage);
            mshSegment.getAcceptAcknowledgmentType().setValue(acceptAcknowledgmentType);
            mshSegment.getApplicationAcknowledgmentType().setValue(applicationAcknowledgmentType);
            mshSegment.getMsh18_CharacterSet(0).setValue("8859/1");
        } catch (HL7Exception ex) {
            throw new IllegalArgumentException(ex);
        }
    }

    /**
     * Populate Patient identification segment.
     *
     * @param pid       segment.
     * @param firstName Patient’s first name.
     * @param lastName  Patient’s last name.
     * @param patientId Identifier used by the healthcare facility to uniquely identify a patient.
     */
    public static void populatePidSegment(final PID pid,
                                          final String firstName,
                                          final String lastName,
                                          final String patientId) {
        try {
            pid.getPatientName(0).getGivenName().setValue(firstName);
            pid.getPatientName(0).getFamilyName().getSurname().setValue(lastName);
            pid.getPatientIdentifierList(0).getID().setValue(patientId);
        } catch (DataTypeException ex) {
            throw new IllegalArgumentException(ex);
        }
    }

    /**
     * Populate Notes and Comments segment.
     *
     * @param nte             segment.
     * @param id              1 for the first NTE, 2 for the second, etc.
     * @param sourceOfComment The software sends the following value: L = Ancillary (filler) department is source of comment.
     * @param comment         Contains the comment (human-readable description).
     */
    public static void populatePatientInfoNotesAndComments(final NTE nte,
                                                           final String id,
                                                           final String sourceOfComment,
                                                           final String comment) {
        try {
            nte.getNte1_SetIDNTE().setValue(id);
            nte.getNte2_SourceOfComment().setValue(sourceOfComment);
            nte.getNte3_Comment(0).setValue(comment);
        } catch (DataTypeException ex) {
            throw new IllegalArgumentException(ex);
        }
    }

    /**
     * Populate "Specimen and container detail" segment.
     *
     * @param sacSegment   segment to be populated.
     * @param tubeBarcode  Tube barcode from host.
     * @param instrumentId This field identifies the type of the carrier.
     * @param rackNumber   Number of the rack on which the tube is located.
     * @param rackPosition Position of the tube in the rack.
     */
    public static void populateSac(final SAC sacSegment,
                                   final String tubeBarcode,
                                   final String instrumentId,
                                   final String rackNumber,
                                   final String rackPosition) {
        try {
            sacSegment.getSac3_ContainerIdentifier().parse(tubeBarcode);
            sacSegment.getSac9_CarrierType().parse(instrumentId);
            sacSegment.getSac10_CarrierIdentifier().parse(rackNumber);
            sacSegment.getSac11_PositionInCarrier().parse(rackPosition);
        } catch (HL7Exception ex) {
            throw new IllegalStateException(ex);
        }
    }


    /**
     * Populate Common Order segment.
     *
     * @param orc                   segment.
     * @param placerOrderNumber     Tube barcode from host.
     * @param priority              Priority. The software supports the following values: R = Routine, S = STAT.
     * @param dateTimeOfTransaction Date/time when the transaction (ORC-1) took place Format: YYYYMMDDhhmmss.
     * @param locationFacility      Order demographic value. Defined in Administration > Import/export > Assign host config. > Demographics > Values
     * @param locationDescription   Text description of Location. Free text defined in Administration > Import/export > Assign host config. > Demographics > Values.
     */
    public static void populateOrc(final ORC orc, final String placerOrderNumber, final String priority,
                                   final String dateTimeOfTransaction, final String locationFacility,
                                   final String locationDescription) {
        try {
            orc.getOrc1_OrderControl().setValue("RE");
            orc.getOrc2_PlacerOrderNumber().getComponent(0).parse(placerOrderNumber);
            orc.getOrc7_QuantityTiming(0).getPriority().setValue(priority);
            orc.getOrc9_DateTimeOfTransaction().getComponent(0).parse(dateTimeOfTransaction);
            orc.getOrc13_EntererSLocation().getComponent(3).parse(locationFacility);
            orc.getOrc13_EntererSLocation().getComponent(8).parse(locationDescription);
        } catch (HL7Exception ex) {
            throw new IllegalArgumentException(ex);
        }
    }

    /**
     * Populate Observation Request segment.
     *
     * @param obr                        segment.
     * @param obrId                      1 for the first OBR, 2 for the second, etc.
     * @param placerOrderNumber          Tube barcode from host (equal to ORC-2).
     * @param universalServiceIdentifier The field contains the identifier code for the ALL requested observation or test.
     * @param priority                   Equal to ORC-7.6 : R = Routine, S = STAT.
     * @param observationDateTime        Date and time when the result was obtained.
     * @param specimenSource             Sample ID received from the host.
     * @param specimenRole               The software supports the following code: P.
     */
    public static void populateObr(final OBR obr, final String obrId, final String placerOrderNumber,
                                   final String universalServiceIdentifier, final String priority, final String observationDateTime,
                                   final String specimenSource, final String specimenRole) {
        try {
            obr.getObr1_SetIDOBR().setValue(obrId);
            obr.getObr2_PlacerOrderNumber().parse(placerOrderNumber);
            obr.getObr4_UniversalServiceIdentifier().parse(universalServiceIdentifier);
            obr.getObr5_Priority().setValue(priority);
            obr.getObr6_RequestedDateTime().getComponent(0).parse(observationDateTime);
            obr.getObr15_SpecimenSource().getComponent(0).parse(specimenSource);
            obr.getObr15_SpecimenSource().getComponent(6).parse(specimenRole);
        } catch (HL7Exception ex) {
            throw new IllegalArgumentException(ex);
        }
    }

    /**
     * Populate Observation/Result segment.
     *
     * @param obx                         segment.
     * @param id                          segment repetition id. 1 for the first OBX, 2 for the second, etc.
     * @param valueType                   This field contains the format of the observation value in OBX. It must be valued if OBX-11-Observ result status is not valued with an X.
     * @param observationIdentifier       Test ID used by the host.
     * @param observationSubId            Unique ID of embedded test and measuring cell combination.
     * @param observationValue            The value of the test result.
     * @param units                       Units of the result reported in OBX-5. (observationValue)
     * @param interpretationCode          Normalcy status of the result.
     * @param observationResultStatus     The software supports values: C = Record is a correction and thus replaces a final result, F = Final result - can only be changed with a corrected result
     * @param dateTimeOfObservation       Date and time when the result arrives in the software.
     * @param producerId                  This field contains the instrument ID followed by the instrument module ID.
     * @param responsibleObserver         The ID of the user who has verified the result.
     * @param equipmentInstanceIdentifier This field contains the instrument ID followed by the instrument module ID (equal to OBX-15.4).
     */
    public static void populateObx(final OBX obx, final String id, final String valueType, final String observationIdentifier,
                                   final String observationSubId, final String observationValue, final String units,
                                   final String interpretationCode, final String observationResultStatus, final String dateTimeOfObservation,
                                   final String producerId, final String responsibleObserver, final String equipmentInstanceIdentifier) {
        try {
            obx.getSetIDOBX().setValue(id);
            obx.getValueType().setValue(valueType);
            obx.getObservationIdentifier().parse(observationIdentifier);
            if (StringUtils.isNotBlank(observationSubId)) {
                obx.getObservationSubId().setValue(observationSubId);
            }
            obx.getObx5_ObservationValue(0).parse(observationValue);
            obx.getUnits().parse(units);
            obx.getAbnormalFlags().setValue(interpretationCode);
            obx.getObservationResultStatus().setValue(observationResultStatus);
            obx.getDateTimeOfTheObservation().getComponent(0).parse(dateTimeOfObservation);
            if (StringUtils.isNotBlank(producerId)) {
                obx.getObx15_ProducerSID().getAlternateIdentifier().parse(producerId);
            }
            if (StringUtils.isNotBlank(responsibleObserver)) {
                obx.getResponsibleObserver().getComponent(1).parse(responsibleObserver);
            }
            if (StringUtils.isNotBlank(equipmentInstanceIdentifier)) {
                obx.getObx18_EquipmentInstanceIdentifier(0).parse(equipmentInstanceIdentifier);
            }
            obx.getDateTimeOfTheAnalysis().getComponent(0).parse(dateTimeOfObservation);
        } catch (HL7Exception ex) {
            throw new IllegalArgumentException(ex);
        }
    }
}
